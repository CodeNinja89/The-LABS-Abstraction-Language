%% declarations

struct message {
    toCore: uint32,
    fromCore: uint32,
    opcode: uint32,
    result: array[uint32],
    params: array[uint32]
};

struct messageQ {
    messages: array[message],
    fill: uint32,
    empty: uint32
};

msg := new message; // the message we want to process. the fields of the message are already set.

msgQ := new messageQ; // the receiver's message queue

function isEmpty: array[message] -> bool;
function getRecvrMsgQ: uint32 -> messageQ;
function checkMessagesCore: array[message], uint32 -> bool;
function opCodeHandler: uint32, array[uint32] -> array[uint32]; // opCodeHandler is the function pouint32er returning an array representing a return result
function getQueueHead: array[message] -> message; // gets the message at the head of the queue (the fill index)

const msgQSize: uint32;
const coreId: uint32; // coreId is an input to the receiver. We treat it as a constant because we assume that we already know what it is.

%% initialisation

%% preconditions

msgQSize > 0;
msgQ.fil == 0;
msgQ.fill < msgQSize;
msgQ.empty >= 0;
msgQ.empty < msgQ.size;
msgQ == getRecvrMsgQ(coreId); // we are talking about the message queue of the uint32ended receiver of this message
msgQ.empty != msgQ.fill;

%% postconditions

msgQ.empty <= msgQ.size;

%% program

msg := getQueueHead(msgQ.messages);
msg.result := opCodeHandler(msg.opcode, msg.params);
msgQ.empty := (msgQ.empty + 1) % msgQSize;
