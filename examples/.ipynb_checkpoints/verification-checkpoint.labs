%% declarations

// Declare all variables as uint32
const x: uint32;
const y: uint32;
z: uint32;
xc: uint32;
yc: uint32;

rc: uint32;
t1: uint32;
t2: uint32;
Azc: uint32;
zc: uint32;

const A: uint32;
const MAGIC: uint32;
Bx: uint32;
By: uint32;
Bz: uint32;
D: uint32;

failed: bool;

%% initialisation

%% preconditions

A == 31541; // 0x7b35
MAGIC ==  4011867933; // 0xEF203F1D
(MAGIC * A) == 1; // MAGIC is the multiplicative inverse of A

// Bx, By, Bz range. Use Z3's Unsigned < (BVULT)
Bx > 0;
Bx < A; // This check is now also uint32

By > 0;
By < A;

Bz > 0;
Bz < A;

// We can use unsigned operators for uint32
// This requires adding ULE/ULT to the grammar,
// or you can just trust the default (signed) ops.
// Let's stick to < for simplicity.
x > 0;
x < 65536;

y > 0;
y < 65536;

x * y < 65536;

D > 0;

xc == (A * x + Bx + D);
yc == (A * y + By + D);

failed == false;

%% postconditions

// These are now bit-vector operations
zc == (A * (x * y) + Bz + D);
(failed == false) => ((z / A) == (x * y));
z % A == 0;

%% program

// All math is now implicitly 32-bit bit-vector math

rc := (xc * yc);
t1 := (((By + D) * xc) + ((Bx + D) * yc) - (Bx * By) - (Bz * A));
t2 := (((Bx + By + A) * D) + (D * D));
Azc := (rc - t1 + t2);

zc := (MAGIC * Azc);

// in the loop, we calculate z from zc. The final result: z % A == 0 and z / A == x * y. The if-condition checks exactly this.
z := (zc - Bz - D);

if((z / A) != (x * y))
{
    failed := true;
}